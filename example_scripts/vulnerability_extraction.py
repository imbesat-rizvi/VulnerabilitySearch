from pathlib import Path
import sys

sys.path.append(str(Path(__file__).parents[1]))


import yaml
import json
from copy import deepcopy

import models
from prompting.Exemplars import ListExemplars
from prompting.structured.xml_utils import enclose_in_xml
from prompting.structured.json_utils import texts_to_jsons

from prepostprocess.extraction_utils import (
    exemplar_json_to_text,
    prepare_prompt_inputs,
)

from data.cve import extraction_template

with open("config/vulnerability_extraction.yaml", "r") as f:
    config = yaml.safe_load(f)

with open(config["exemplars"]["filepath"], "r") as f:
    data = json.load(f)

    exemplars = data[config["exemplars"]["exemplars_key"]]
    exemplars = exemplar_json_to_text(
        exemplars,
        json_key=config["exemplars"]["response_key"],
        **config["exemplars"]["response_conversion_kwargs"],
    )

    schema_type = "xml" if "xml" in config["template"] else config["template"]
    system_prompt = data[config["exemplars"]["prompt_key"]]
    system_prompt = system_prompt["base"] + system_prompt["schema"].get(schema_type, "")

    if schema_type == "xml":
        template = enclose_in_xml(config["template"])
        system_prompt = system_prompt.format(xml_template=template)
    else:
        template = getattr(extraction_template, schema_type)
        if parser := config["model"]["init_kwargs"].get("parser"):
            if parser == "JsonSchemaParser":
                template = template.model_json_schema()
            config["model"]["init_kwargs"]["parser_schema"] = template

exemplars = ListExemplars(exemplars=exemplars)

vulnerabilities = [
    "CRLF injection vulnerability in xterm allows user-assisted attackers to execute arbitrary commands via LF (aka \\n) characters surrounding a command name within a Device Control Request Status String (DECRQSS) escape sequence in a text file, a related issue to CVE-2003-0063 and CVE-2003-0071.",
    'The WebWork 1 web application framework in Atlassian JIRA before 3.13.2 allows remote attackers to invoke exposed public JIRA methods via a crafted URL that is dynamically transformed into method calls, aka "WebWork 1 Parameter Injection Hole."',
]

vuln_inp = prepare_prompt_inputs(
    vulnerabilities,
    system_prompt=system_prompt,
    exemplars=exemplars,
    query_key=config["exemplars"]["query_key"],
    response_key=config["exemplars"]["response_key"],
    return_as_text=True,
    **config["exemplars"]["sample_kwargs"],
)

model = getattr(models, config["model"]["model_class"])(
    **config["model"]["init_kwargs"]
)

vuln_out = model.generate(
    vuln_inp,
    generation_config=config["model"]["generation_config"],
)

# flatten the output using first generation
vuln_json = [o[0] for o in vuln_out]

# import pdb; pdb.set_trace()
if isinstance(vuln_json[0], str):
    vuln_json = texts_to_jsons(vuln_json)
    # only consider the first json as output
    vuln_json = [j[0] for j in vuln_json]

print(vuln_json)
