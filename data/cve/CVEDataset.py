import json
import time
from pathlib import Path
from datetime import datetime, timedelta, timezone
from requests.auth import HTTPBasicAuth
from functools import partial

import requests
from datasets import Dataset
from tqdm import tqdm


class CVEDataset:

    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    def __init__(
        self,
        cve_file=None,  # cve file name if it is already downloaded
        cache_dir=None,  # directory where cve file is downloaded or to be downloaded
        api_key=None,  # api key, if available, for cve data from nvd website
        # None or isoformat string e.g. YYYY-MM-DD, if cve_file is None, defaults to 121 days before the current utc
        lastModStartDate=None,
        # None or isoformat string e.g. YYYY-MM-DD, if cve_file is None, defaults to 1 day before the current utc
        lastModEndDate=None,
        overwrite_existing=False,  # if true and cve_file is None, redownload
        api_sleep_seconds=6,  # sleep seconds between NVD api call
    ):

        self.lastModStartDate, self.lastModEndDate = self._parse_dates(
            lastModStartDate, lastModEndDate
        )

        self.api_sleep_seconds = api_sleep_seconds

        auth = HTTPBasicAuth("apiKey", api_key)
        self.get_response = partial(requests.get, auth=auth)

        if cache_dir:
            self.cache_dir = Path(cache_dir)
        else:
            self.cache_dir = Path(__file__).parents[1] / "cache"

        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.cve_file = self._check_and_create_filename(cve_file)
        if cve_file is None and overwrite_existing:
            self.cve_file.unlink(missing_ok=True)

        self.raw_data = self._get_raw_data()

        print("Creating Huggingface dataset from raw json data...")
        self.data = Dataset.from_generator(self._vulnerability_generator)
        print("Huggingface dataset created.")

    def _parse_dates(self, lastModStartDate=None, lastModEndDate=None):
        if lastModEndDate is None:
            # one day before current UTC date to ensure fetched data reproducibility
            lastModEndDate = datetime.now(timezone.utc)
            lastModEndDate = (lastModEndDate - timedelta(days=1)).date().isoformat()
        lastModEndDate = datetime.fromisoformat(lastModEndDate)

        if lastModStartDate is None:
            # NVD api currently supports date range of 120 days. source:
            # https://nvd.nist.gov/developers/vulnerabilities
            # Longer ranges needs to be looped through explicitly
            lastModStartDate = (lastModEndDate - timedelta(days=120)).date().isoformat()
        lastModStartDate = datetime.fromisoformat(lastModStartDate)

        return lastModStartDate, lastModEndDate

    def _check_and_create_filename(self, cve_file):
        if cve_file is None:
            file_id = f"lastModStartDate-{self.lastModStartDate.isoformat()}"
            file_id += f"-lastModEndDate-{self.lastModEndDate.isoformat()}"
            cve_file = f"cve-{file_id}.json"
        cve_file = self.cache_dir / cve_file
        return cve_file

    def _get_raw_data(self):
        raw_data = dict()
        if self.cve_file.exists():
            print("Reading raw CVE data from json file...")
            with open(self.cve_file, "r") as f:
                raw_data = json.load(f)
            print("Raw CVE data loaded.")

        else:
            print("Downloading raw CVE data from NVD API...")
            raw_data = self._download_raw_data()
            with open(self.cve_file, "w") as f:
                json.dump(raw_data, f, indent=2)
            print("Raw CVE data downloaded.")

        return raw_data

    def _fetch_raw_data(self, query_url):
        response = self.get_response(query_url)
        # it is still recommended that your application sleeps
        # for several seconds between requests.
        # It is recommended that users "sleep" their scripts
        # for six seconds between requests. source:
        # https://nvd.nist.gov/developers/start-here#
        time.sleep(self.api_sleep_seconds)

        data = dict()
        if response.content:
            data = json.loads(response.content)
        return data

    def _download_raw_data(self):

        # NVD api currently supports max range of 120 days. source:
        # https://nvd.nist.gov/developers/vulnerabilities
        max_date_range = timedelta(days=120 + 1)  # 1 offset for non-overlap batches

        last_mod_end_dates = []
        cur_end_date = self.lastModEndDate
        while cur_end_date > self.lastModStartDate:
            last_mod_end_dates.append(cur_end_date)
            cur_end_date -= max_date_range
        max_date_range = timedelta(days=120)  # to calculate inclusive start dates

        data = dict(format="", version="", vulnerabilities=[])
        query_template = self.BASE_URL + "?lastModStartDate={lmsd}"
        query_template += "&lastModEndDate={lmed}"
        query_template += "&startIndex={sidx}"

        for lmed in tqdm(last_mod_end_dates):
            lmsd = max(self.lastModStartDate, lmed - max_date_range)
            sidx = 0  # startIndex

            query_url = query_template.format(
                lmsd=lmsd.isoformat(), lmed=lmed.isoformat(), sidx=sidx
            )

            cur_data = self._fetch_raw_data(query_url)
            data["format"] = cur_data.get("format", "NVD_CVE")
            data["version"] = cur_data.get("version", "2.0")
            data["vulnerabilities"].extend(cur_data.get("vulnerabilities", []))

            sidx_start = sidx_step = cur_data["resultsPerPage"]
            sidx_end = cur_data["totalResults"]
            for sidx in tqdm(range(sidx_start, sidx_end, sidx_step)):

                query_url = query_template.format(
                    lmsd=lmsd.isoformat(), lmed=lmed.isoformat(), sidx=sidx
                )

                cur_data = self._fetch_raw_data(query_url)
                data["vulnerabilities"].extend(cur_data.get("vulnerabilities", []))

        return data

    def _vulnerability_generator(self):

        for i, v in enumerate(self.raw_data["vulnerabilities"]):
            vul = {"idx": i, "cve_id": v["cve"]["id"], "descriptions": ""}

            for d in v["cve"]["descriptions"]:
                if d["lang"] == "en":
                    vul["descriptions"] = d["value"]
                    break

            yield vul
